import bpy, blf
import math
from bpy_extras import view3d_utils
from mathutils import *
from .utils import *
from .resources import *

class OffsetModalOperator(bpy.types.Operator):
    """Executing offset with the value determined by mouse position"""
    bl_idname = "gpencil.nijigp_offset_selected_modal"
    bl_label = "Offset Selected (Modal)"
    bl_options = {'REGISTER', 'UNDO'}

    starting_mouse_x: bpy.props.IntProperty()
    offset_amount: bpy.props.FloatProperty(
            name='Offset',
            default=0, unit='LENGTH',
            description='Offset length'
    )
    multiframe_falloff: bpy.props.FloatProperty(
            name='Multiframe Falloff',
            default=0, min=0, max=1,
            description='The ratio of offset length falloff per frame in the multiframe editing mode',
    )
    corner_shape: bpy.props.EnumProperty(
            name='Corner Shape',
            items=[('JT_ROUND', 'Round', ''),
                    ('JT_SQUARE', 'Square', ''),
                    ('JT_MITER', 'Miter', '')],
            default='JT_ROUND',
            description='Shape of corners generated by offsetting'
    )
    end_type_mode: bpy.props.EnumProperty(
            name='End Type',
            items=[('ET_CLOSE', 'Fill', ''),
                    ('ET_OPEN', 'Line', ''),
                    ('ET_CLOSE_CORNER', 'Corner', '')],
            default='ET_CLOSE',
            description='Offset a stroke as either an open line or a closed fill shape'
    )

    def modal(self, context, event):
        if event.type == 'MOUSEMOVE':
            delta = (event.mouse_x - self.starting_mouse_x) / LINE_WIDTH_FACTOR
            bpy.ops.ed.undo()
            bpy.ops.ed.undo_push()
            context.area.header_text_set('Offset: {:f} m'.format(delta))
            bpy.ops.gpencil.nijigp_offset_selected(offset_amount=delta,
                                                   corner_shape=self.corner_shape,
                                                   end_type_mode=self.end_type_mode,
                                                   multiframe_falloff=self.multiframe_falloff)   

        elif event.type == 'LEFTMOUSE':
            context.area.header_text_set(None)
            return {'FINISHED'}
        
        elif event.type in {'RIGHTMOUSE', 'ESC'}:
            context.area.header_text_set(None)
            bpy.ops.ed.undo()
            return {'CANCELLED'}

        return {'RUNNING_MODAL'}

    def invoke(self, context, event):
        if context.object:
            self.starting_mouse_x = event.mouse_x
            context.window_manager.modal_handler_add(self)
            bpy.ops.ed.undo_push()
            bpy.ops.gpencil.nijigp_offset_selected(offset_amount=0) 
            return {'RUNNING_MODAL'}
        else:
            self.report({'WARNING'}, "No active object, could not finish")
            return {'CANCELLED'}

class RollViewModalOperator(bpy.types.Operator):
    """Drag to roll the view, or click to undo all previous rolling"""
    bl_idname = "gpencil.nijigp_roll_view_modal"
    bl_label = "Roll the View (Modal)"
    bl_options = {'REGISTER'}

    mouse_x: bpy.props.IntProperty()
    starting_mouse_x: bpy.props.IntProperty()
    moving_rate: bpy.props.FloatProperty(default=0.01)
    moving_threshold: bpy.props.IntProperty(default=5)

    def modal(self, context, event):
        if event.type == 'MOUSEMOVE':
            delta = (event.mouse_x - self.mouse_x) * self.moving_rate
            accumulated_delta = (event.mouse_x - self.starting_mouse_x) * self.moving_rate
            self.mouse_x = event.mouse_x
            rotation: Euler = Quaternion(self.region.view_rotation).to_euler()
            rotation.rotate_axis('Z', delta)
            self.region.view_rotation = rotation.to_quaternion()
            context.area.header_text_set('Angle: {:f} degrees'.format(math.degrees(accumulated_delta)))

        elif event.type == 'LEFTMOUSE':
            # Reset the angle if clicking the mouse instead of dragging
            if abs(event.mouse_x - self.starting_mouse_x) < self.moving_threshold:
                if 'nijigp_view_rotation' in context.scene and context.scene['nijigp_view_rotation']:
                    for i,area in enumerate(context.screen.areas):
                        if area.type == 'VIEW_3D':
                            for j,space in enumerate(area.spaces):
                                key=str([i,j])
                                space.region_3d.view_rotation = context.scene['nijigp_view_rotation'][key]
                context.scene['nijigp_view_rotation'] = None
            context.area.header_text_set(None)
            return {'FINISHED'}
        
        elif event.type in {'RIGHTMOUSE', 'ESC'}:
            self.region.view_rotation = self.original_rotation
            context.area.header_text_set(None)
            return {'CANCELLED'}

        return {'RUNNING_MODAL'}

    def invoke(self, context, event):
        self.region: bpy.types.RegionView3D = None
        if context.region_data:
            self.region = context.region_data

            if self.region.view_perspective == 'CAMERA':
                self.region.view_perspective = 'ORTHO'
            self.mouse_x = event.mouse_x
            self.starting_mouse_x = event.mouse_x
            context.window_manager.modal_handler_add(self)

            # Save the current rotation information
            self.original_rotation = Quaternion(self.region.view_rotation)
            if 'nijigp_view_rotation' not in context.scene or not context.scene['nijigp_view_rotation']:
                context.scene['nijigp_view_rotation'] = {}
                for i,area in enumerate(context.screen.areas):
                    if area.type == 'VIEW_3D':
                        for j,space in enumerate(area.spaces):
                            key=str([i,j])
                            context.scene['nijigp_view_rotation'][key] = Quaternion(space.region_3d.view_rotation)
            return {'RUNNING_MODAL'}
        else:
            return {'CANCELLED'}

class ArrangeModalOperator(bpy.types.Operator):
    """
    Drag left/right to arrange strokes downward/upward
    """
    bl_idname = "gpencil.nijigp_arrange_modal"
    bl_label = "Arrange Strokes (Modal)"
    bl_options = {'REGISTER', 'UNDO'}

    max_display: bpy.props.IntProperty(default=100)
    font_id: bpy.props.IntProperty(default=0)
    starting_mouse_x: bpy.props.IntProperty()
    arrange_offset: bpy.props.IntProperty(default=0)
    moving_rate: bpy.props.FloatProperty(default=0.01)

    def draw_callback_px(self, op, context):
        """
        Show the order of the active layer&frame by number
        """
        if context.object and context.object.type=='GPENCIL':
            layers = context.object.data.layers
            if layers.active and not layers.active.hide and layers.active.active_frame:
                strokes = layers.active.active_frame.strokes
                if len(strokes)<self.max_display:
                    for i,stroke in enumerate(strokes):
                        if len(stroke.points)>0:
                            # Render the number text on each stroke
                            # Mark the starting point for open stroke and center for closed/fill stroke
                            if is_stroke_line(stroke, context.object) and not stroke.use_cyclic:
                                view_co = view3d_utils.location_3d_to_region_2d(context.region, 
                                                                                context.space_data.region_3d, 
                                                                                stroke.points[0].co)
                            else:
                                view_co = view3d_utils.location_3d_to_region_2d(context.region, 
                                                                                context.space_data.region_3d, 
                                                                                (stroke.bound_box_min+stroke.bound_box_max)*0.5)                                
                            if stroke.select:
                                blf.color(self.font_id, 1, 0.5, 0.5, 1)
                            else:
                                blf.color(self.font_id, 0, 0, 0, 1)
                            blf.enable(self.font_id, blf.SHADOW)
                            blf.shadow(self.font_id, 3, 0.8, 0.8, 0.8, 0.95)
                            blf.size(self.font_id, 36 if stroke.select else 24, 72)
                            blf.position(self.font_id, view_co[0], view_co[1], 0)
                            blf.draw(self.font_id, str(i))

    def modal(self, context, event):
        context.area.tag_redraw()

        if event.type == 'MOUSEMOVE':
            delta = round((event.mouse_x - self.starting_mouse_x) * self.moving_rate)
            if delta > self.arrange_offset:
                for i in range(delta-self.arrange_offset):
                    bpy.ops.gpencil.stroke_arrange(direction='UP')
            elif delta < self.arrange_offset:
                for i in range(self.arrange_offset-delta):
                    bpy.ops.gpencil.stroke_arrange(direction='DOWN')
            self.arrange_offset = delta 
            context.area.header_text_set('Arrangement Offset: {:d}'.format(self.arrange_offset))
        elif event.type == 'LEFTMOUSE':
            context.area.header_text_set(None)
            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
            return {'FINISHED'}            
        elif event.type in {'RIGHTMOUSE', 'ESC'}:
            context.area.header_text_set(None)
            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
            return {'CANCELLED'}
        return {'RUNNING_MODAL'}

    def invoke(self, context, event):
        self.starting_mouse_x = event.mouse_x
        self.arrange_offset = 0

        args = (self, context)
        self._handle = bpy.types.SpaceView3D.draw_handler_add(
            self.draw_callback_px, args, 'WINDOW', 'POST_PIXEL'
        )
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

class OffsetTool(bpy.types.WorkSpaceTool):
    bl_space_type = 'VIEW_3D'
    bl_context_mode = 'EDIT_GPENCIL'

    bl_idname = "nijigp.offset_tool"
    bl_label = "2D Offset"
    bl_description = (
        "Offset/inset the shape of selected strokes with mouse dragging. "
        "Holding CTRL for corner mode, or holding SHIFT for line mode"
    )
    bl_icon = get_workspace_tool_icon('ops.nijigp.offset_tool')
    bl_widget = None
    bl_keymap = (
        ("gpencil.nijigp_offset_selected_modal", {"type": 'LEFTMOUSE', "value": 'PRESS'},
         {"properties": []}),
        ("gpencil.nijigp_offset_selected_modal", {"type": 'LEFTMOUSE', "value": 'PRESS', "ctrl": True},
         {"properties": [("end_type_mode", 'ET_CLOSE_CORNER')]}),
        ("gpencil.nijigp_offset_selected_modal", {"type": 'LEFTMOUSE', "value": 'PRESS', "shift": True},
         {"properties": [("end_type_mode", 'ET_OPEN')]}),
    )

    def draw_settings(context, layout, tool):
        props = tool.operator_properties("gpencil.nijigp_offset_selected_modal")
        layout.prop(props, "corner_shape")
        layout.prop(props, "multiframe_falloff")

class ViewportShortcuts(bpy.types.GizmoGroup):
    bl_idname = "nijigp_viewport_shortcuts"
    bl_label = "NijiGPen Viewport Shortcuts"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'WINDOW'
    bl_options = {'PERSISTENT', 'SCALE'}

    @classmethod
    def poll(cls, context):
        return (context.mode=='EDIT_GPENCIL' or context.mode=='PAINT_GPENCIL' or context.mode=='SCULPT_GPENCIL')

    def draw_prepare(self, context):
        preferences = context.preferences.addons[__package__].preferences
        if not preferences.shortcut_button_enabled:
            return
        region = context.region
        spacing = preferences.shortcut_button_spacing
        total_width = len(self.gizmo_list) * self.button_size * 4 * context.preferences.view.ui_scale
        for i, gizmo in enumerate(self.gizmo_list):
            if gizmo:
                if preferences.shortcut_button_style == 'BOTTOM':
                    gizmo.matrix_basis[0][3] = (region.width/2 + total_width/2
                                                - self.button_size*spacing*(i+1) * context.preferences.view.ui_scale
                                                + preferences.shortcut_button_location[0])
                    gizmo.matrix_basis[1][3] = self.button_size*2 + preferences.shortcut_button_location[1]
                elif preferences.shortcut_button_style == 'TOP':
                    gizmo.matrix_basis[0][3] = (region.width/2 + total_width/2
                                                - self.button_size*spacing*(i+1) * context.preferences.view.ui_scale
                                                + preferences.shortcut_button_location[0])
                    gizmo.matrix_basis[1][3] = region.height - self.button_size*4 - preferences.shortcut_button_location[1]
                elif preferences.shortcut_button_style == 'RIGHT':
                    gizmo.matrix_basis[0][3] = region.width - self.button_size*3 - preferences.shortcut_button_location[0]
                    gizmo.matrix_basis[1][3] = (self.button_size*spacing*(i+1) * context.preferences.view.ui_scale
                                                + preferences.shortcut_button_location[1])   
                else:             
                    gizmo.matrix_basis[0][3] = self.button_size*6 + preferences.shortcut_button_location[0]
                    gizmo.matrix_basis[1][3] = (self.button_size*spacing*(i+1) * context.preferences.view.ui_scale
                                                + preferences.shortcut_button_location[1])                    
    def setup(self, context):
        preferences = context.preferences.addons[__package__].preferences
        if not preferences.shortcut_button_enabled:
            return
        self.gizmo_list = []
        self.button_profile_list = [{'op': 'ed.redo', 'icon': 'LOOP_FORWARDS'},
                               {'op': 'ed.undo', 'icon': 'LOOP_BACK'},
                               None,
                               {'op': 'gpencil.nijigp_roll_view_modal', 'icon': 'FILE_REFRESH'},
                               None,
                               {'op': 'gpencil.stroke_arrange', 'icon': 'TRIA_UP_BAR', 'direction': 'TOP'},
                               {'op': 'gpencil.nijigp_arrange_modal' ,'icon': 'MOD_DISPLACE'},
                               {'op': 'gpencil.stroke_arrange', 'icon': 'TRIA_DOWN_BAR', 'direction': 'BOTTOM'}
                               ]
        self.button_size = preferences.shortcut_button_size 
        for profile in self.button_profile_list:
            if profile:
                button = self.gizmos.new("GIZMO_GT_button_2d")
                button.draw_options = {'BACKDROP', 'OUTLINE'}
                button.scale_basis = self.button_size
                button.icon = profile['icon']
                op = button.target_set_operator(profile['op'])
                if 'direction' in profile:
                    op.direction = profile['direction']

                button.color = 0.3, 0.3, 0.3
                button.alpha = 0.5
                button.color_highlight = 0.6, 0.6, 0.6
                button.alpha_highlight = 0.5
                self.gizmo_list.append(button)
            # Add a placeholder as a separator in the viewport
            else:
                self.gizmo_list.append(None)

class RefreshGizmoOperator(bpy.types.Operator):
    bl_idname = "gpencil.refresh_gizmo"
    bl_label = "Refresh Viewport Shortcuts"

    def execute(self, context):
        bpy.utils.unregister_class(ViewportShortcuts)
        bpy.utils.register_class(ViewportShortcuts)
        return {'FINISHED'}

def register_viewport_tools():
    bpy.utils.register_tool(OffsetTool, after={"builtin.transform_fill"}, separator=True)

def unregister_viewport_tools():
    bpy.utils.unregister_tool(OffsetTool)